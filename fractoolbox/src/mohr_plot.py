# ==============
# # 3D Mohr Plot
# ==============
'''
A set of functions that draw the 3D Mohr plot for a given stress tensor
or ratio between the components of the stress tensor (ie normalised to
the vertical stress or effective vertical stress.

Contributions
-------------
fractoolbox was initiated by Irene Wallis https://github.com/ICWallis/fractoolbox
as part of Doctoral Research at the University of Auckland that is 
supervised by David Dempsey https://github.com/ddempsey and 
Julie (JR) Rowland, with math/code contributions from Evert Dur√°n 
https://github.com/edur409.

License 
-------
fractoolbox is distributed under an Apache 2.0 license
https://choosealicense.com/licenses/apache-2.0/
'''

def sigma_m(bigS,smallS):
    '''
    Part of the set of functions required to generate a 3D Mohr plot
    
    This function is called by the Mohr3D() function
    Input is a stress pair, as defined in the dictionary in Mohr3D()
    Output is the mean stresses given the effective stress tensor.
    Function adapted by Irene from Evert's method.
    '''
    sigma_m=(bigS+smallS)/2
    return sigma_m

def tau_s(bigS,smallS):
    """Part of the set of functions required to generate a 3D Mohr plot

    A minimum and maximum effective stress is passed in (x axis on Mohr plot) and 
    the function returns an associated range of shear stresses (y axis on the Mohr plot).
    The number and range of angles generated (np.linspace) must match the sigma_n 
    so the result of these functions can be plotted together. 
    Args:
        bigS ([type]): Minimum point of the arc
        smallS ([type]): [description]

    Returns:
        [type]: [description]

    Function adapted by Irene from Evert's method.
    """
    theta=np.ndarray.tolist(np.linspace(0,180,50)*np.pi/180)
    tau_s=np.sin(2*theta)*(bigS-smallS)/2
    return tau_s

def sigma_n(bigS,smallS):
    '''
    Part of the set of functions required to generate a 3D Mohr plot

    This function is called by the Mohr3D() function
    Input is a stress pair, as defined in the dictionary in Mohr3D()
    Output is the range of normal stresses possible given the effective stress tensor
    Note that the number and range of angles generated by np.linspace
    must match the tau_s() function for these to be plotted together.
    Function adapted by Irene from Evert's method.
    '''
    theta=np.ndarray.tolist(np.linspace(0,180,50)*np.pi/180)
    sigma_n=((bigS+smallS)/2)+np.cos(2*theta)*(bigS-smallS)/2
    return sigma_n

def mohr3d(S1,S2,S3,N):
    '''
    Make the arcs of the 3D Mohr plot normalised to N

    Two groups of inputs:
        (1) effective stresses sigma1, sigma2, sigma3 
            ie the three principle stresses minus the pore pressure.
        (2) A normalisation value (N) which is usually the effective vertical stress
    Calls three other functions:
        - sigma_m()
        - tau_s()
        - sigma_n() 
    The function generates a dictionary of stress pairs,
    then generates two outputs:
        - a list (meanS) and
        - two sets of that contain three arrays each (tauS & meanS).
    Plot meanS as x axis with y axis = [0,0,0].
    Plot tauS and normS by stripping the arrays.
    Example code for generating tauS, normS as objects and plot:
    $
    # make a dictionary
    pltpairs = {  
        "normStauS":
        [(normS[0],tauS[0]), #sigma1,sigma3 pair
        (normS[1],tauS[1]),  #sigma1,sigma2 pair
        (normS[2],tauS[2])]}  #sigma2,sigma3 pair
    # plot from a for loop
    for normS, tauS in pltpairs['normStauS']:
        ax.plot(normS,tauS,'k',linewidth=0.5)
    $
    The function is written by Irene based Evert's method
    '''
    # define pairs of stress magnitude to draws the arcs between    
    Spairs = {  
                "bigSsmallS":
                [(S1/N,S3/N), # sigma1,sigma3 normalised to N
                (S1/N,S2/N),  # sigma1,sigma2 normalised to N
                (S2/N,S3/N)]  # sigma2,sigma3 normalised to N
                }

    # generate sets of arrays for plotting 
    # uses the dictionary Spairs above
    tauS = []
    for bigS, smallS in Spairs['bigSsmallS']:
        t = tau_s(bigS,smallS)
        tauS.append(t)
    normS = []
    for bigS, smallS in Spairs['bigSsmallS']:
        nm = sigma_n(bigS,smallS)
        normS.append(nm)
    meanS = []
    for bigS, smallS in Spairs['bigSsmallS']:
        m = sigma_m(bigS,smallS)
        meanS.append(m)
    
    return tauS, normS, meanS